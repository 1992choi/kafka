# Apache Kafka

<br><br>

## 개념 정리
### 카프카가 데이터 파이프라인으로 적합한 이유
- 높은 처리량
  - 카프카는 프로듀서가 브로커로 데이터를 보낼 때와 컨슈머가 브로커로부터 데이터를 받을 때, 모두 묶어서 전송하고 받는다.
  - 많은 양이 많아지면, 데이터를 송수신할 때 맺어지는 네트워크 비용은 무시할 수 없는 규모가 되는데 네트워크 통신 횟수를 줄일다면 동일 시간 내에 더 많은 데이터를 전송할 수 있다.
  - 파티션 단위를 통해 동일 목적의 데이터를 여러 파티션에 분배하고 데이터를 병렬 처리할 수 있다.
- 확장성
  - 카프카는 가변적인 환경에서 안정적으로 확장 가능하도록 설계되었다.
  - 데이터가 많아지면 클러스터의 브로커 개수를 자연스럽게 늘려 스케일 아웃할 수 있다.
- 영속성
  - 카프카는 다른 메시징 플랫폼과 다르게 데이터를 메모리에 저장하지 않고, 파일 시스템에 저장한다.
  - 파일 시스템을 이용하다보니 느리다고 생각할 수 있겠지만, 파일I/O 성능 향상을 위해 페이지 캐시 영역을 메모리에 따로 생성하여 사용한다.
    - 한 번 읽은 파일 내용은 메모리에 저장시켰다가 다시 사용하는 방식이기 때문에 성능이 향상된다.
  - 파일 시스템을 활용하기 때문에 장애가 발생하여 급작스럽게 종료되더라도 프로세스를 재시작하여 안전하게 데이터를 다시 처리할 수 있다.
- 고가용성
  - 3개 이상의 서버들로 운영되는 카프카 클러스터는 일부 서버에 장애가 발생하더라도 무중단으로 안전하고 지속적인 데이터 처리가 가능하다.

### 카프카 브로커
- ![img.png](img/broker.png)
  - 카프카 브로커는 카프카 클라이언트와 데이터를 주고받기 위해 사용하는 주체이다.
  - 데이터를 분산 저장하여 장애가 발생하더라도 안전하게 사용할 수 있도록 도와주는 애플리케이션이다.
  - 하나의 서버에는 하나의 브로커 프로세스가 실행된다.
  - 카프카 브로커 서버 1대로도 기본 기능이 실행되지만, 안전성을 위하여 3대 이상의 브로커 서버를 사용하고 이를 1개의 클러스터로 묶어 사용하기도 한다.
  - 카프카 클러스터를 실행하기 위해서는 주키퍼가 필요하다.
    - 주키퍼는 브로커들의 상태를 관리하고, 클러스터를 조율하기 위해 사용된다.
  - 카프카 3.0 부터는 주키퍼가 없어도 클러스터 동작이 가능하지만, 아직까지는 정식버전으로 지원하지는 않는다.

### 브로커의 역할
- 컨트롤러
  - 클러스터의 다수 브로커 중 한 대가 컨트롤러의 역할을 한다.
  - 컨트롤러는 다른 브로커들의 상태를 체크하고 브로커가 클러스터에서 빠지는 경우, 해당 브로커에 존재하는 리더 파티션을 재분배한다.
- 데이터 저장
  - server.properties의 log.dir 옵션에 정의한 디렉토리에 데이터를 저장한다.
- 데이터 삭제
  - 카프카는 다른 메시징 플랫폼과 다르게 컨슈머가 데이터를 가져가더라도 데이터가 삭제되지 않는다.
  - 또한 컨슈머나 프로듀서가 데이터 삭제 요청을 할 수도 없다.
  - 오직 브로커만이 데이터를 삭제할 수 있는데, 데이터 삭제는 파일 단위로 이루어지며 이 단위를 로그 세그먼트라고 부른다.
  - 세그먼트에는 다수의 데이터가 들어있으며, 일반적인 데이터베이스와 다르게 특정 데이터를 선별해서 삭제하는 것은 불가능하다.
- 컨슈머 오프셋 저장
  - 어느 레코드까지 가져갔는지 확인하기 위해 오프셋을 커밋한다.
    - 커밋한 오프셋은 __consumer_offsets 토픽에 저장된다.
- 그룹 코디네이터
  - 코디네이터는 컨슈머 그룹의 상태를 체크하고, 파티션을 컨슈머와 매칭되도록 분배하는 역할을 한다.
  - 컨슈머가 컨슈머 그룹에서 빠지면, 매칭되지 않은 파티션을 정상 동작하는 컨슈머로 할당하여 끊임없이 데이터가 처리되도록 도와준다.
    - 파티션을 컨슈머로 재할당하는 과정을 리밸런스(rebalance)라고 한다.
- 복제
  - 카프카는 복제를 통해 클러스터로 묶인 브로커 중 일부에 장애가 발생하더라도 데이터를 유실하지 않고 안전하게 사용할 수 있도록 처리해준다.
  - 카프카의 데이터 복제는 파티션 단위로 이루어진다.
  - 토픽을 생성할 때 파티션의 복제 개수(replication factor)를 설정할 수 있다.
    - 옵션을 선택하지 않으면 브로커에 설정된 옵션 값을 따라간다.
    - 복제 개수의 최솟값은 1(복제안함)이고 최댓값은 브로커 개수만큼 설정할 수 있다.
  - 복제된 파티션은 리더와 팔로워로 구성된다.
    - 프로듀서 또는 컨슈머와 직접 통신하는 파티션은 리더이며, 나머지 팔로워 파티션은 복제된 데이터를 가지고 있기위해 존재한다.
  - 리더 파티션이 사용할 수 없게되면, 팔로워 파티션 중 하나가 리더 파티션 지위를 넘겨받는다.
  - ISR(In-Sync Replica)
    - ISR은 리더 파티션과 팔로워 파티션이 모두 싱크된 상태를 뜻한다.
      - 상황에 따라 리더 파티션의 모든 데이터를 복제하지 못하였는데, 리더 파티션이 사용할 수 없게되는 경우도 있음. 
      - 이 때, 옵션에 따라 데이터 유실을 감수하고 팔로워 파티션을 리더로 승급할지 지정할 수 있다.
        - unclean.leader.election.enable=true
          - 데이터 유실을 감수함. 복제가 안된 팔로워 파티션을 리더로 승급.
        - unclean.leader.election.enable=false
          - 데이터 유실을 감수하지 않음. 해당 브로커가 복구될 때까지 중단.